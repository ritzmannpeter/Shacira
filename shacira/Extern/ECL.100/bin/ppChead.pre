################################
##
##   C-Head  $Revision: 1.1 $
##
################################


##
## $Id: ppChead.pre,v 1.1 2002/04/19 16:52:27 epting Exp $
##
## Versuch einer Emulation des Slick-Makros C-Head
##
## HISTORY:
##   03.10.93  -NB-  Freigabe der Version 1.00
##   11.01.94  -NB-  Ende des Interface-Teils auch mit C++ Kommentar
##                   Version 1.01
##   06.04.96  -NB-  Einsatz von RCS
##   06.06.02  -MW-  Generierung von /*.SH.*/ und /*.EH.*/ entfernt,
##                   Modulkopf fuer cpp-Dateien mit //-Kommentaren
##


## Konfiguration:
##
##   Laberfilter: Hat die folgende Konstante den Wert 1, so
##   werden noch mehr Meldungen ausgegeben.

#define MESSAGES 0

##   Test auf rekursives Abarbeiten der Headerfiles
##   (bei Intel-Compilern mit zusaetzlichen Zeilen):

#define REC_TEST 0
#define INTEL    0

##   Klammerung der include-Anweisung mit ifdef

#define INC_TEST 0  ## "normale"  Header
#define STD_TEST 0  ## <standard> Header

## Erzeugen von '#line'-Anweisungen in jedem INTERFACE-Block

#define GEN_LINE 0

## Auszufilternde Schlsselw”rter

#define EXPORT    EXPORT


##
## Inkompatibilitaeten (bisher bekannte):
##
##   Globale Deklarationen werden nur dann erkannt, wenn sie auf das
##   Schluesselwort GLOBAL folgen.
##
##   Prototypen werden ohne "extern" angegeben.
##
## Bugs:
##
##   Innerhalb eines Strings, der Teil einer globalen Variableninitiali-
##   sierung ist, fuehrt ein Kommentaranfang zu absonderlichen Effekten:
##
##      GLOBAL char a[] = "Das geht schief /*"
##


##########################################
##                                      ##
##   Konstanten, Mengen und Variablen   ##
##                                      ##
##########################################


#define VERSION     "$Revision: 1.1 $"

#set IDENT          %[_A-Za-z0-9*]     ## Erkennt Bezeichner (mit Sternchen bei Zeigern)

#var Module                            ## Enthaelt Modulnamen
#var m_count                           ## Zaehler fuer State 'match'
#var g                                 ## Zeilenspeicher fuer den State 'global'
#var flag                              ## Flag fuer den Zustand 'function'


##########################
##                      ##
##   Filterfunktionen   ##
##                      ##
##########################


## --- f_normal --------------------------------------------------------------
##
## Sucht einen Kommentar und gibt diesen an f_comment weiter

#func f_normal:
   %c /* %c   : $1 $(setfilter(f_comment):) $(f_comment:$2) .


## --- f_comment -------------------------------------------------------------
##
## Sucht das Kommentarende und verschluckt den Kommentar

#func f_comment:
   %c */ %c   : $(setfilter(f_normal):) $(f_normal:$2) .
   %c         : .


##############################
##                          ##
##   Init- und Startregel   ##
##                          ##
##############################


## --- init ------------------------------------------------------------------
##
## Falls gewuenscht erfolgt hier eine Versionsangabe

#init:
   ({MESSAGES} == 1 ? $(message: "This is C-Head Version " $(GetVersion:{VERSION})\n\n ) ) .


## --- start -----------------------------------------------------------------
##
## Hier wird der Dokukopf des Headerfiles und die Abpruefung auf rekursiven
## Aufruf erzeugt (bei Intel etwas komplizierter). Ausserdem werden die
## Variablen initialisiert.

#start:
   $(message: "[C-Head] " $(right(15): "              " $(__INPUT__)) " -> " $(__OUTPUT__) \n )
   $(setvar(m_count):0)
   $(setvar(Module): $(name: $(__INPUT__)))

   $(head_comment: $(ext: $(__INPUT__)))

##    "// ---------------------------------------------------------------------------\n"
##    "//\n"
##    "//  Headerfile for module " $(Module) "\n"
##    "//\n"
##    "//  Generated by C-Head Version " $(GetVersion:{VERSION}) \n
##    "//  (c) 1993-2002 by 2i Industrial Informatics GmbH\n"
##    "//\n"
##    "//  This file has been extracted from the source file\n"
##    "//  " $(__INPUT__) " on " $(__FULLDATE__) \n
##    "//\n"
##    "// ---------------------------------------------------------------------------\n\n"

   "#ifndef " $(head_def:$(Module)) \n
   "#define " $(head_def:$(Module)) \n\n

   ( {REC_TEST} == 1 ?
      "#ifdef " $(in_def:$(Module)) \n
      "#  error \"" $(Module) ".h included recursively\"\n"
      ( {INTEL} == 1 ?
         "/* some junk especially for the iC86 compiler: */\n"
         "#  include \"file " $(Module) ".h included recursively\"\n"
      )
      "#else\n"
      "#  define " $(in_def:$(Module)) \n
      "#endif\n\n"
   ) .


####################
##                ##
##   Funktionen   ##
##                ##
####################


## --- GetVersion ------------------------------------------------------------
##
## Nummer der RCS-Version extrahieren

#func GetVersion:
   %c %d \. %d %c :  $2 \. $3 .
   %c             : "<unknown>" .

## --- name ------------------------------------------------------------------
##
## Den Modulnamen aus dem Dateinamen extrahieren:
##    "PFAD\MODULE.C" => "Module"

#func name:
   %c %( \\ | \: | / ) %c   : $(name:$3) .
   %c "."  %c               : $(name:$1) .
   %1-c                     : $1 .
   %c                       : $(message:
                                 "[C-Head] Warning: "
                                 "Cannot extract module name from '" $(__INPUT__) '\n )
                              "<unknown>" .


## --- ext ---------------------------------------------------------------- MW
##
## Den Erweiterung aus dem Dateinamen extrahieren:
##    "PFAD\MODULE.EXT" => "EXT" (im Zweifelsfall CPP annehmen)

#func ext:
   %c %( \\ | \: | / ) %c   : $(name:$3) .
   %c "."  %c               : $(name:$2) .
   %1-c                     : $(lower:$1) .
   %c                       : $(message:
                                 "[C-Head] Warning: "
                                 "Cannot extract module extension from '" $(__INPUT__) '\n )
                              "CPP" .

## --- head_comment ------------------------------------------------------- MW
##
## fuer CPP einen neuen Header mit // erzeugen, sonst mit /* ... */

#func head_comment:
   "cpp" :
      "// ---------------------------------------------------------------------------\n"
      "//\n"
      "//  Headerfile for cpp module " $(Module) "\n"
      "//\n"
      "//  Generated by C-Head Version " $(GetVersion:{VERSION}) \n
      "//  (c) 1993-2002 by 2i Industrial Informatics GmbH\n"
      "//\n"
      "//  This file has been extracted from the source file\n"
      "//  " $(__INPUT__) " on " $(__FULLDATE__) \n
      "//\n"
      "// ---------------------------------------------------------------------------\n\n" .
   %c :
      "/*\n"
      " *  Headerfile for " $1 " module " $(Module) "\n"
      " *\n"
      " *  Generated by C-Head Version " $(GetVersion:{VERSION}) \n
      " *  (c) 1993-2002 by 2i Industrial Informatics GmbH\n"
      " *\n"
      " *  This file has been extracted from the source file\n"
      " *  " $(__INPUT__) " on " $(__FULLDATE__) \n
      " */\n\n" .




## --- head_def --------------------------------------------------------------
##
## Aus Modulnamen die Header-Konstante bilden:
##    "Module" => "__module__"

#func head_def:
   %c   : "__" $(lower:$1) "__" .


## --- in_def ----------------------------------------------------------------
##
## Aus Modulnamen die Konstante zur Rekursionspruefung bilden:
##    "Module" => "__in_module__"

#func in_def:
   %c   : "__in_" $(lower:$1) "__" .


## --- proc_inc --------------------------------------------------------------
##
## Includeanweisung bearbeiten:
##    Bei Text==1 mit viel Brimborium, sonst einfach und schlicht

#func proc_inc(head,fname):   ## Gedoens um include-Anweisung
   1    : "#ifndef " $(head) \n
          "#  include " $(fname) \n
          "#  ifndef " $(head) \n
          "#    define " $(head) \n
          "#  endif\n"
          "#endif\n" .
   %c   : "#include " $(fname) \n .


## --- exit ------------------------------------------------------------------
##
## Abschluss des Headerfiles (bei Rekursionstest mit zusaetzlichem #undef)
## Ist ein Text vorhanden, so wird er als Fehlermeldung ausgegeben.

#func exit:
   %c   : ($1 ? $(error("\n[C-Head] " $1):) )
          ({REC_TEST} == 1 ? "\n#undef " $(in_def:$(Module)) )
          "\n#endif\n"
          "\n" .

#func _check:
   %( {EXPORT} )  : .
   %c             : $1 .

#func check:
   %c %1-t %[*] %c   : ($(_check:$1) ? $1 $2) $3 $(check:$4) .
   %c                : $(_check:$1) .


###################
##               ##
##   Zustaende   ##
##               ##
###################


## --- normal ----------------------------------------------------------------
##
## Grundzustand: erkennt den INTERFACE-Teil sowie lokale und globale Daten
## Dies ist der einzige Zustand, in dem ein EOF erlaubt ist.
##

#state normal:
   "#ifdef" %t "__INTERFACE__" %c   : ({GEN_LINE} == 1 ? "#line " $(add(1):$(__LINE__)) " \"" $(__INPUT__) "\"\n" | )
                                      $[interface] .
   "/*.SL.*/" %c                    : $[local:$1] .
   "/*.SP.*/" %c                    : $[public:$1] .
   "GLOBAL" %1-t %c                 : $[global:$2] $(setvar(g):) $(setfilter(f_normal):) .
   %c "/*" %c                       : $[wait("*/"):$2] .
   %c                               : .
   <EOF>                            : $(exit:) .


## --- interface -------------------------------------------------------------
##
## Wartet auf "#endif /* __INTERFACE__ */" und uebernimmt bis dahin alles
## unveraendert. Einzige Ausnahme sind include-Anweisungen, die an proc_inc()
## weitergegeben werden.

#state interface:
   "#endif" %t "/" %1[/*] %t "__INTERFACE__" %c   : $[normal] .
   "#"%t"include"%t %(\"|\<)%c%(\"|\>) %c   : $(proc_inc( $(head_def: $(name:$4)), $3$4$5$6 ):
                                                 ($3 == \" ? {INC_TEST} | {STD_TEST}) ) .
   %c                                       : $1 \n .
   <EOF>                                    : $(exit: "Unexpected EOF in INTERFACE part" ) .


## --- local -----------------------------------------------------------------
##
## Verschluckt alle Zeichen bis "/*.EL.*/"

#state local:
   %c "/*.EL.*/" %c   : $[normal: $2] .
   %c                 : .
   <EOF>              : $(exit: "Unexpected EOF in local part" ) .


## --- public ----------------------------------------------------------------
##
## Ubernimmt alles bis "/*.EP.*/

#state public:
   %c "/*.EP.*/" %c   : $1 \n $[normal:$2] .
   %c                 : $1 \n .
   <EOF>              : $(exit: "Unexpected EOF in public part" ) .


## --- global ----------------------------------------------------------------
##
## Es folgt eine globale Deklaration: Zunaechst werden Bezeichner in der
## Variable g gesammelt. Folgt eine Klammer, so handelt es sich um eine
## Funktion, sonst ist es eine Variable.

#state global:
   %t %1-IDENT %c   : $(setvar(g): ($(g) ? $(g) " ") $2) $[global:$3] .
   %t "(" %c        : $(check:$(g)) "(" $[function:$2] $(setvar(flag):).
   %t %c            : "extern " $(g) $[variable:$2] .
   <EOF>            : $(exit:"Unexpected EOF in global part" ) .


## --- function --------------------------------------------------------------
##
## Die Argumente der Funktion bis zur geschweiften Klammer werden ausgegeben.
## Ist die Argumentliste mehrzeilig, so wird eingerueckt.

#state function:        ## Alles bis "{"
   %c "{" %c   : $1 ";\n" $[normal:$2] $(setfilter():) .
   %t %c       : ($(flag) ? \n "   " | " " ) $2 $(setvar(flag):YES) .
   <EOF>       : $(exit: "Unexpected EOF in function declaration" ) .


## --- variable --------------------------------------------------------------
##
## Untersuchung einer Variablendeklaration. Die Moeglichkeiten sind:
##    "=" : Initialisierung => weiter mit v_init
##    "[" : Felddeklaration => Warten auf schliessende Klammer
##    "," : Variablenliste  => weiter mit v_next
##    ";" : Ende            => weiter mit normal

#state variable:
   %t "=" %t %c   :       $[v_init:$3] .
   %t "[" %c      : "["   $[v_array:$2] .
   %t "," %t %c   : ", "  $[v_next:$3] .
   %t ";" %c      : ";\n" $[normal:$2] $(setfilter():) .
   %c             : .
   <EOF>          : $(exit: "Unexpected EOF in variable declaration" ) .


## --- v_next ----------------------------------------------------------------
##
## Bezeichner lesen und zurueck zu variable

#state v_next:
   %t %IDENT %t %c   : $2 $[variable:$4] .
   %c                : .
   <EOF>             : $(exit: "Unexpected EOF in variable declaration" ) .


## --- v_array ---------------------------------------------------------------
##
## Liest Feldindizes und gibt alle bis auf den letzten aus

#state v_array:
   %c "]" %t "[" %c   : $1 "][" $[v_array:$3] .
   %c "]" %c          : "]" $[variable:$2] .
   %c                 : $1 \n .
   <EOF>              : $(exit: "Unexpected EOF in array declaration" ) .


## --- v_init ----------------------------------------------------------------
##
## Die gesamte Variableninitialisierung wird ueberlesen, sie endet mit einem
## Komma oder einem Strichpunkt. Eine Feld- oder Strukturinitialisierung
## wird mit Hilfe des Zustands match ignoriert.

#state v_init:
   %c %( \" | ";" | "," | "{" ) %c   : ($2 == \"   ? $[wait(\"):$3])
                                       ($2 == ","  ? $[return:"," $3])
                                       ($2 == ";"  ? $[return:";" $3])
                                       ($2 == "{"  ? $[match("{","}"):$3]) .
   %c                                : .
   <EOF>                             : $(exit: "Unexpected EOF in initializer" ) .


## --- string ----------------------------------------------------------------
##
## Ein String wird ueberlesen, wobei auch C-Spezialitaeten erkannt werden.
## Das Endezeichen kann angegeben werden.

#state string(eos):
   %c %( \\ | $(eos) ) %-1c %c   : ($2 == \\ ? $[string($(eos)):$4] )
                                   ($2 == $(eos) ? $[return:$3 $4] ) .
   %c                            : .


## --- wait ------------------------------------------------------------------
##
## Der Zustand wartet auf das angegebene Zeichen und kehrt zurueck

#state wait(token):
   %c $(token) %c   : $[return:$2] .
   %c               : .
   <EOF>            : $(exit: "Unexpected EOF while waiting for '" $(token) ' ) .


## --- match -----------------------------------------------------------------
##
## Hier wird bis zur passenden schliessenden Klammer des Paares (in,out) alles
## ignoriert. Die Variable m_count muss mit 0 initalisiert werden.

#state match(in,out):   ## Sucht passendes "out" zu "in"
   %c %( \" | \' | $(in) | $(out) ) %c   : $[match($(in),$(out)):$3]
                                           ($2 == \"     ? $[string(\"):$3] )
                                           ($2 == \'     ? $[string(\'):$3] )
                                           ($2 == $(out) ?
                                               ($(m_count) == 0 ? $[return:$3] | $(dec(m_count):) )
                                           )
                                           ($2 == $(in)  ? $(inc(m_count):) ) .
   %c                                    : .
   <EOF>                                 : $(exit: "Unexpected EOF while waiting for '" $(in) ' ) .


#end
