/*.SH.*/

/*
 *  Headerfile for module eb_base
 *
 *  Generated by C-Head Version 1.3
 *  (c) 1993 by 2i Industrial Informatics GmbH
 *
 *  This file has been extracted from the source file
 *  eb_base.cpp on Saturday March 23 2002  18:55:53
 */

#ifndef __eb_base__
#define __eb_base__


// Headerfiles
// ==========================================================================

#if _MSC_VER >= 1300
   #if defined ECL_DLL_WIN_EXPORTS
      #pragma warning(disable:4995) /* name was marked as #pragma deprecated */
      #include <iostream.h>
   #else
      #include <iostream>
      using std::istream;
      using std::ostream;
      using std::cin;
      using std::cout;
      using std::cerr;
      using std::endl;
   #endif
#else
   #include <iostream.h>
#endif

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>


// Current Compiler / Target System
// ===========================================================================

#if defined __OS2__
   #define __ECL_OS2__
#elif defined _WIN32 || defined __WIN32__
   #define __ECL_W32__
#else
   #error "Unsupported target system for ECL"
#endif

#if defined __IBMCPP__
   #define __ECL_ICC__
#elif _MSC_VER >= 1100
   #define __ECL_VCPP__ _MSC_VER
#elif __BCPLUSPLUS__ >= 0x0540
   #define __ECL_BCPP__ __BCPLUSPLUS__
#else
   #error "Unsupported compiler for ECL"
#endif

#if !defined __ECL_DEBUG__
   #if defined __ECL_VCPP__
      #if defined _DEBUG
         #define __ECL_DEBUG__ 1
      #else
         #define __ECL_DEBUG__ 0
      #endif
   #else
      #define __ECL_DEBUG__ 0    /* 0 = Release, 1 = Debug */
   #endif
#endif

#if defined __ECL_ICC__

   #define __ECL_DLLEXPORT__        _Export
   #define __ECL_OPEXP__            /* empty */
   #define __ECL_EXP1__             /* empty */
   #define __ECL_EXP2__             _Export
   #define __ECL_THREADLNK__        _Optlink
   #define __ECL_SHOW_LEAKS__()     /* TBD: ??? */

   #define dbg_new(s,f,l)           ::operator new(s)
   #define dbg_delete(p,f,l)        ::operator delete(p)

   #define __ECL_MAKE_DLL__         /* TBD: ??? */
   #define __ECL_MAKE_LIB__         /* TBD: ??? */
   #define __ECL_MAKE_EXE__         /* TBD: ??? */

#elif defined __ECL_VCPP__

   #pragma warning(disable:4514) /* Nichtreferenzierte Inline-Funktion wurde entfernt */
   #pragma warning(disable:4710) /* Funktion ist keine Inline-Funktion */
   #pragma warning(disable:4786) /* Bezeichner auf 255 Zeichen begrenzt in Debug-Information */

   #if __ECL_VCPP__ < 1200
      #pragma warning(disable:4201) /* Nicht dem Standard entsprechende Erweiterungen */
   #endif

   #define __ECL_EXP2__             /* empty */
   #define __ECL_THREADLNK__        __cdecl

   #if defined __ECL_DEBUG__ > 0 && _MSC_VER >= 1200 && _MSC_VER < 1300
      #include <crtdbg.h>
      #define __ECL_SHOW_LEAKS__()     _CrtDumpMemoryLeaks()
      #define dbg_new(s,f,l)        ::operator new(s, _NORMAL_BLOCK, f, l)
      #define dbg_delete(p,f,l)     ::operator delete(p, _NORMAL_BLOCK, f, l)
      inline void *operator new(size_t size, int line, const char *file)
         { return dbg_new(size, file, line); }
      inline void operator delete(void *ptr, int line, const char *file)
         { dbg_delete(ptr, file, line); }
   #else
      #define __ECL_SHOW_LEAKS__()
      #define dbg_new(s,f,l)        ::operator new(s)
      #define dbg_delete(p,f,l)     ::operator delete(p)
   #endif

   #if defined _USRDLL
      #define __ECL_MAKE_DLL__
      #define __ECL_DLLEXPORT__        __declspec(dllexport)
      #define __ECL_OPEXP__            __declspec(dllexport)
      #define __ECL_EXP1__             __declspec(dllexport)
   #else
      #define __ECL_DLLEXPORT__
      #define __ECL_OPEXP__
      #define __ECL_EXP1__
      #if defined _LIB
         #define __ECL_MAKE_LIB__
      #else
         #define __ECL_MAKE_EXE__
      #endif
   #endif

#elif defined __ECL_BCPP__

   #define __ECL_DLLEXPORT__        /* empty */
   #define __ECL_OPEXP__            /* empty */
   #define __ECL_EXP1__             /* empty */
   #define __ECL_EXP2__             /* empty */
   #define __ECL_THREADLNK__        __cdecl
   #define __ECL_SHOW_LEAKS__()     /* TBD: ??? */

   #define dbg_new(s,f,l)           ::operator new(s)
   #define dbg_delete(p,f,l)        ::operator delete(p)

   #define __ECL_MAKE_DLL__         /* TBD: ??? */
   #define __ECL_MAKE_LIB__         /* TBD: ??? */
   #define __ECL_MAKE_EXE__         /* TBD: ??? */

#endif

#if defined __ECL_DEBUG__ == 0
   #undef __ECL_SHOW_LEAKS__
   #define __ECL_SHOW_LEAKS__()  /* empty */
#endif


// Dynamic Memory Allocation
// ===========================================================================

#if defined __ECL_DEBUG__ > 0 && __ECL_VCPP__ >= 1200 && __ECL_VCPP__ < 1300
   #define op_new0(s)            new(s, int line, const char *file)
   #define op_new1(s,p1)         new(s, p1, int line, const char *file)
   #define op_new2(s,p1,p2)      new(s, p1, p2, int line, const char *file)
   #define op_delete0(p)         delete(p, int line, const char *file)
   #define op_delete1(p,p1)      delete(p, p1, int line, const char *file)
   #define op_delete2(p,p1,p2)   delete(p, p1, p2, int line, const char *file)
   #define new0                  new(__LINE__, __FILE__)
   #define new1(p1)              new(p1, __LINE__, __FILE__)
   #define new2(p1,p2)           new(p1, p2, __LINE__, __FILE__)
#else
   #define op_new0(s)            new(s)
   #define op_new1(s,p1)         new(s, p1)
   #define op_new2(s,p1,p2)      new(s, p1, p2)
   #define op_delete0(p)         delete(p)
   #define op_delete1(p,p1)      delete(p, p1)
   #define op_delete2(p,p1,p2)   delete(p, p1, p2)
   #define new0                  new
   #define new1(p1)              new(p1)
   #define new2(p1,p2)           new(p1, p2)
#endif


// Utility Macros
// ===========================================================================

// Assertion (nur Bedingung)
// Liefert false im Fehlerfall
#if __ECL_DEBUG__ > 0
   #define __ECL_ASSERT1__(c) \
      ( (c) ? true : cBase::DbgAssert1(#c, __FILE__, __LINE__) )
#else
   #define __ECL_ASSERT1__(c) \
      (c)
#endif

// Assertion (Bedingung + Meldung)
// Liefert false im Fehlerfall
#if __ECL_DEBUG__ > 0
   #define __ECL_ASSERT2__(c,p) \
      ( __ECL_ASSERT1__(c) ? true : cBase::DbgAssert2 p )
#else
   #define __ECL_ASSERT2__(c,p) \
      (c)
#endif

#if defined __ECL_ICC__
   // Typ bool, Gestaltung konform mit ANSI-C++-Typ bool.
   enum { false = 0, true = 1 };
   #define bool int
#endif

// Typ EBHDL, muss long und Pointer aufnehmen koennen
typedef unsigned long EBHDL;

// Speziell fuer MakeHead
#define GLOBAL


// Utility Macros / Templates
// ===========================================================================

#if defined max
   #undef max
#endif

#if defined __ECL_ICC__
   #define max(a,b) (((a) > (b)) ? (a) : (b))
#else
   template<class T> inline T max(T a, T b)
      { return (a > b) ? a : b; }
#endif

#if defined min
   #undef min
#endif

#if defined __ECL_ICC__
   #define min(a,b) (((a) < (b)) ? (a) : (b))
#else
   template<class T> inline T min(T a, T b)
      { return (a < b) ? a : b; }
#endif


// Utility Functions
// ===========================================================================

inline char * strxcpy(char *s1, const char *s2, size_t len)
   { strncpy(s1, s2, len); s1[len-1] = '\0'; return s1; }

inline char * strpadcpy(char *s1, const char *s2, size_t len)
   { for ( char *s = s1 ; len-- ; s++ ) if ( *s2 ) *s = *s2++; else *s = ' '; return s1; }

inline const char *Nvl(const char *s, const char *r)
   { return s ? s : r; }

inline const char *Evl(const char *s, const char *r)
   { return s ? (*s ? s : r) : r; }

inline char *rtrim(char *s)
   { for ( char *p=s+strlen(s) ; p>s && *(p-1)==' ' ; ) *(--p) = '\0'; return s; }


// ===========================================================================
// Definition cBase
// ---------------------------------------------------------------------------
//
// Die Basis aller Klassen.
//
// cBase
//
// ===========================================================================

class __ECL_DLLEXPORT__ cBase {
private:
#ifdef __ECL_BCPP__
   int destructed;
public:
   cBase::cBase();
   virtual cBase::~cBase();
#endif
public:
   typedef int (*PRINT_FUNC)(const char * fmt, ... );

   struct MASK_NAME {
      unsigned long mask;
      const char *name;
   };

   enum DBG_MASK {
      dbgError    = 0x00000001,     // Fehlermeldungen
      dbgInfo     = 0x00000002,     // Allgemeine Infos
      dbgTrcBase  = 0x00000004,     // Trace: Methoden der Basisklassen
      dbgTrcDb    = 0x00000008,     // Trace: Methoden der Datenbankklassen
      dbgTrcWin   = 0x00000010,     // Trace: Methoden der Windowklassen
      dbgTrcApp   = 0x00000200,     // Trace: Methoden der Anwendungsklassen
      dbgBase     = 0x00000020,     // Basisklassen-Spezifisches
      dbgDb       = 0x00000040,     // Datenbankklassen-Spezifisches
      dbgWin      = 0x00000080,     // Windowklassen-Spezifisches
      dbgSql      = 0x00000100,     // Alle SQL-Befehle
      dbgSqlRaw   = 0x00000800,     // SQL-Befehle im DB-spezifischen Format
      dbgMsg      = 0x00000400,     // Meldungs-Spezifisches
      dbgAssert   = 0x00008000,     // ECL-Assertions "weiterwerfen"
      dbgUser     = 0x00010000      // Frei fuer Benutzer
   };

   static void DbgOut(unsigned long mask, const char *fmt, ...);
   static void DbgVOut(unsigned long mask, const char *fmt, va_list ap);
   static void DbgError(const char *fmt, ...);
   static bool DbgAssert1(const char *expr, const char *file, int line);
   static bool DbgAssert2(const char *fmt, ...);
   static void DbgInfo(const char *fmt, ...);
   static void DbgTrcBase(const char *fmt, ...);
   static void DbgTrcDb(const char *fmt, ...);
   static void DbgTrcWin(const char *fmt, ...);
   static void DbgTrcApp(const char *fmt, ...);
   static void DbgBase(const char *fmt, ...);
   static void DbgDb(const char *fmt, ...);
   static void DbgWin(const char *fmt, ...);
   static void DbgSql(const char *sql);
   static void DbgSqlRaw(const char *sql);
   static void DbgMsg(const char *fmt, ...);

   static void setDebugMask(unsigned long mask);
   static void setDebugMask(const char *str);
   static unsigned long getDebugMask();

   static void setPrintFunc(PRINT_FUNC _printf);
   static void setLogfile(const char *fname, bool append = true);
   static void setLogfileDimension(int max_gen, long max_size);

   static void setDebugWindow(EBHDL hwnd = NULL);
   static void paintDebugWindow();

   static unsigned long getMask(const char *string, MASK_NAME *tab, unsigned long def);
};


// ===========================================================================
// Definition cData
// ---------------------------------------------------------------------------
//
// cBase
//  +--cData
//
// ===========================================================================

class __ECL_DLLEXPORT__ cData : public cBase {

// Informationen zur Klasse
// ========================
// GetDataInfo() - Liefert einen eindeutigen 32-Bit-Wert, der die Datenklasse
//    beschreibt (in Form eines 4-Zeichen Eyecatchers)
//
// GetDataSize() - Liefert die Groesse des Datenbereiches (unabhaengig von der
//    tatsaechlichen Groesse des Objektes!)

public:
   virtual long GetDataInfo() const { return 0x5f5f5f5fL /*'____'*/; }
   virtual long GetDataSize() const { return 0; }


// Informationen zur Instanz
// =========================
// GetDataStart() - Liefert einen char-Zeiger auf die Startadresse (d.h. das
//    erste Byte) des Datenbereiches

   virtual char *GetDataStart() { return (char *)this; }

};


// ===========================================================================
// Definition cLogfile
// ---------------------------------------------------------------------------
//
// cLogfile
//
// ===========================================================================

class __ECL_DLLEXPORT__ cLogfile {

public:
   // Logdatei festlegen und aktivieren, ggf. löschen (append == false)
   // oder Logdatei deaktivieren (fname == 0).
   cLogfile(const char *fname = 0, bool append = true);
   void setFile(const char *fname = 0, bool append = true);
   // Protokolldatei ermitteln (0 = deaktiviert)
   const char *getFile();
   // Logdateigenerationen und Dateigroesse (0 = kein Limit) festlegen
   void setLimits(int max_gen, long max_size);
   // Logdateigenerationen und Dateigroesse ermitteln
   void getLimits(int &max_gen, long &max_size);
   // Zeile in Logdatei schreiben ('\n' wird angefügt!)
   void write(const char *text);

private:
   enum {
      MAX_LOGFILE_NAME = 132,
      DEF_LOGFILE_SIZE = 524288, // Standarddateigroesse: 512 KByte
      DEF_LOGFILE_GEN  = 3       // Standardgenerationenzahl
   };

   char logfile_name[MAX_LOGFILE_NAME];
   long max_logfile_size;  // Groesse einer einzelnen Datei
   int max_logfile_gen;    // Anzahl Generationen

   void theNextGeneration();
};


// ===========================================================================
// Definition cOsBase
// ---------------------------------------------------------------------------
//
// Basisklasse zur Realisierung von betriebssystemspezifischen Objekten
// (OS-Objekt), die typischerweise ueber ein Identifikations-Handle verfuegen.
// Ueber die spezielle Methode getHandleFrom() kann die Implementierung des
// OS-Objektes auf normalerweise verdeckte Handles anderer OS-Objekte zu-
// greifen.
//
// cBase
//  +--cOsBase
//
// ===========================================================================

class __ECL_DLLEXPORT__ cOsBase : public cBase {

protected:

   class __ECL_DLLEXPORT__ cOsHandle {

   public:
   #if defined __ECL_OS2__

      cOsHandle(unsigned long h = 0)
         { cOsHandle::h = h; }
      unsigned long * operator & ()
         { return &h; }
      operator unsigned long () const
         { return h; }
      void invalidate()
         { h = 0; }
      bool isNull() const
         { return h == 0; }
      bool isValid() const
         { return h != 0; }

   private:
      unsigned long h;

   #elif defined __ECL_W32__

      cOsHandle(void *h = NULL)
         { cOsHandle::h = h; }
      void ** operator & ()
         { return &h; }
      operator void * () const
         { return h; }
      void invalidate()
         { h = NULL; }
      bool isNull() const
         { return h == NULL; }
      bool isValid() const
         { return h != NULL; }

   private:
      void *h;

   #endif

   };

   // Handle des betriebssystem-spezifischen Objektes
   cOsHandle handle;

   // Erfragen von Handles anderer betriebssystem-spezifischer Objekte
   static const cOsHandle getHandleFrom(const cOsBase& other)
      { return other.handle; }
   // Setzen von Handles anderer betriebssystem-spezifischer Objekte (Gefaehrlich!!!)
   static void setHandleOf(cOsBase& other, const cOsHandle& h)
      { other.handle = h; }

};


#endif

/*.EH.*/
